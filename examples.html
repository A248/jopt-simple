<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.4 at 2014-10-29 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>JOpt Simple - a Java command line parsing library - Examples of Usage</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20141029" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                                      <a href="./" id="bannerLeft">
                                                <img src="images/jopt-simple-logo.png" alt="JOpt Simple" />
                </a>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2014-10-29</span>
                  &nbsp;| <span id="projectVersion">Version: 4.8</span>
                      </div>
            <div class="xright">        
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                <h5>JOpt Simple</h5>
                  <ul>
                  <li class="none">
                          <a href="index.html" title="Overview">Overview</a>
            </li>
                  <li class="none">
                          <a href="download.html" title="Download">Download</a>
            </li>
                  <li class="none">
            <strong>Examples</strong>
          </li>
                  <li class="none">
                          <a href="changes.html" title="Change Log">Change Log</a>
            </li>
                  <li class="none">
                          <a href="apidocs/index.html" title="Javadoc">Javadoc</a>
            </li>
                  <li class="none">
                          <a href="developer.html" title="Developer Docs">Developer Docs</a>
            </li>
                  <li class="none">
                          <a href="acknowledgments.html" title="Acknowledgements">Acknowledgements</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                                            <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                            <li class="collapsed">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                  </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section">
<h2>Preamble<a name="Preamble"></a></h2>
<p>The simplicity in JOpt &quot;Simple&quot; arises from two guiding principles:</p>
<ul>
<li>Stick as often as possible to supporting conventional Unix option syntaxes.</li>
<li>Keep the surface area of the published API as small and simple as possible.</li></ul>
<p>To the first principle: You will not see support in JOpt Simple for option &quot;groups&quot;, alternative option prefixes (<tt>+</tt>, <tt>/</tt>), enforced multiplicity of option arguments, etc. JOpt Simple believes you can create a useful and understandable CLI without all that stuff. If you feel as though you need any of those features, there are lots of other choices out there. The author of JOpt Simple believes you'll want to leverage its easy configuration, parsing, and option interrogation APIs instead of using more feature-laden, but perhaps more confusing libraries.</p>
<p>To the second principle: JOpt Simple will make every attempt to keep the API free of clutter. The API is well factored, making it intuitive to use, and the entire library is well tested, making it more reliable and predictable. If you cannot look at the Javadoc and quickly get a sense of what you need to do to use JOpt Simple, then JOpt Simple has failed. So by all means, let the author know what needs improved.</p>
<p>With that said, let's take a tour through JOpt Simple's features.</p></div>
<div class="section">
<h2>Options<a name="Options"></a></h2>
<p>JOpt Simple supports short options and long options, using a syntax that attempts to take from the best of POSIX <tt>getopt()</tt> and GNU <tt>getopt_long()</tt>.</p>
<div class="section">
<h3>Short Options<a name="Short_Options"></a></h3>
<p>Short options begin with a single hyphen (<tt>-</tt>) followed by a single letter or digit, or question mark (<tt>?</tt>), or dot (<tt>.</tt>).</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class ShortOptionsTest {
    @Test
    public void supportsShortOptions() {
        OptionParser parser = new OptionParser( &quot;aB?*.&quot; );

        OptionSet options = parser.parse( &quot;-a&quot;, &quot;-B&quot;, &quot;-?&quot; );

        assertTrue( options.has( &quot;a&quot; ) );
        assertTrue( options.has( &quot;B&quot; ) );
        assertTrue( options.has( &quot;?&quot; ) );
        assertFalse( options.has( &quot;.&quot; ) );
    }
}
</pre></div>
<p>When you construct an <tt>OptionParser</tt> with a string of short option characters, you configure that parser to recognize the options with those characters.</p>
<div class="section">
<h4>Arguments of Options<a name="Arguments_of_Options"></a></h4>
<p>Short options can accept single arguments. The argument can be made required or optional. When you construct an <tt>OptionParser</tt> with a string of short option characters, append a single colon (<tt>:</tt>) to an option character to configure that option to require an argument. Append two colons (<tt>::</tt>) to an option character to configure that option to accept an optional argument. Append an asterisk (<tt>*</tt>) to an option character, but before any &quot;argument&quot; indicators, to configure that option as a &quot;help&quot; option.</p>
<p>The syntax of the option specification string given to the <tt>OptionParser</tt> constructor should look familiar to you if you have used GNU's <tt>getopt()</tt> before.</p>
<div class="source">
<pre>package joptsimple.examples;

import static java.util.Arrays.*;
import static java.util.Collections.*;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class ShortOptionsWithArgumentsTest {
    @Test
    public void allowsOptionsToAcceptArguments() {
        OptionParser parser = new OptionParser( &quot;fc:q::&quot; );

        OptionSet options = parser.parse( &quot;-f&quot;, &quot;-c&quot;, &quot;foo&quot;, &quot;-q&quot; );

        assertTrue( options.has( &quot;f&quot; ) );

        assertTrue( options.has( &quot;c&quot; ) );
        assertTrue( options.hasArgument( &quot;c&quot; ) );
        assertEquals( &quot;foo&quot;, options.valueOf( &quot;c&quot; ) );
        assertEquals( asList( &quot;foo&quot; ), options.valuesOf( &quot;c&quot; ) );

        assertTrue( options.has( &quot;q&quot; ) );
        assertFalse( options.hasArgument( &quot;q&quot; ) );
        assertNull( options.valueOf( &quot;q&quot; ) );
        assertEquals( emptyList(), options.valuesOf( &quot;q&quot; ) );
    }
}
</pre></div>
<div class="section">
<h5>Specifying Arguments for a Short Option on the Command Line<a name="Specifying_Arguments_for_a_Short_Option_on_the_Command_Line"></a></h5>
<p>A short option's argument can occur:</p>
<ul>
<li>in the position on the command line after the option</li>
<li>right up against the option</li>
<li>right up against the option separated by an equals sign (<tt>=</tt>)</li></ul>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class ShortOptionsWithArgumentPositioningTest {
    @Test
    public void allowsDifferentFormsOfPairingArgumentWithOption() {
        OptionParser parser = new OptionParser( &quot;a:b:c::&quot; );

        OptionSet options = parser.parse( &quot;-a&quot;, &quot;foo&quot;, &quot;-bbar&quot;, &quot;-c=baz&quot; );

        assertTrue( options.has( &quot;a&quot; ) );
        assertTrue( options.hasArgument( &quot;a&quot; ) );
        assertEquals( &quot;foo&quot;, options.valueOf( &quot;a&quot; ) );

        assertTrue( options.has( &quot;b&quot; ) );
        assertTrue( options.hasArgument( &quot;b&quot; ) );
        assertEquals( &quot;bar&quot;, options.valueOf( &quot;b&quot; ) );

        assertTrue( options.has( &quot;c&quot; ) );
        assertTrue( options.hasArgument( &quot;c&quot; ) );
        assertEquals( &quot;baz&quot;, options.valueOf( &quot;c&quot; ) );
    }
}
</pre></div></div>
<div class="section">
<h5>Multiple Arguments for a Single Option<a name="Multiple_Arguments_for_a_Single_Option"></a></h5>
<p>To specify <i>n</i> arguments for a single option, specify the option <i>n</i> times on the command line, once for each argument. JOpt Simple reports the arguments given to the option in the order in which they were encountered on the command line.</p>
<div class="source">
<pre>package joptsimple.examples;

import static java.util.Arrays.*;

import joptsimple.OptionException;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import static org.junit.Assert.*;
import static org.junit.rules.ExpectedException.*;

public class ShortOptionsWithMultipleArgumentsForSingleOptionTest {
    @Rule public final ExpectedException thrown = none();

    @Test
    public void allowsMultipleValuesForAnOption() {
        OptionParser parser = new OptionParser( &quot;a:&quot; );

        OptionSet options = parser.parse( &quot;-a&quot;, &quot;foo&quot;, &quot;-abar&quot;, &quot;-a=baz&quot; );

        assertTrue( options.has( &quot;a&quot; ) );
        assertTrue( options.hasArgument( &quot;a&quot; ) );
        assertEquals( asList( &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ), options.valuesOf( &quot;a&quot; ) );

        thrown.expect( OptionException.class );
        options.valueOf( &quot;a&quot; );
    }
}
</pre></div></div></div>
<div class="section">
<h4>Clustering Short Options<a name="Clustering_Short_Options"></a></h4>
<p>Short options can be <i>clustered</i> in a single argument.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class ShortOptionsClusteringTest {
    @Test
    public void allowsClusteringShortOptions() {
        OptionParser parser = new OptionParser( &quot;aBcd&quot; );

        OptionSet options = parser.parse( &quot;-cdBa&quot; );

        assertTrue( options.has( &quot;a&quot; ) );
        assertTrue( options.has( &quot;B&quot; ) );
        assertTrue( options.has( &quot;c&quot; ) );
        assertTrue( options.has( &quot;d&quot; ) );
    }
}
</pre></div>
<p>If one of the short options can accept an argument, the remaining characters are interpreted as the argument for that option.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class ShortOptionsClusteringWithArgumentTest {
    @Test
    public void allowsClusteringShortOptionsThatAcceptArguments() {
        OptionParser parser = new OptionParser();
        parser.accepts( &quot;a&quot; );
        parser.accepts( &quot;B&quot; );
        parser.accepts( &quot;c&quot; ).withRequiredArg();

        OptionSet options = parser.parse( &quot;-aBcfoo&quot; );

        assertTrue( options.has( &quot;a&quot; ) );
        assertTrue( options.has( &quot;B&quot; ) );
        assertTrue( options.has( &quot;c&quot; ) );
        assertEquals( &quot;foo&quot;, options.valueOf( &quot;c&quot; ) );
    }
}
</pre></div></div></div>
<div class="section">
<h3>Long Options/Fluent Interface<a name="Long_OptionsFluent_Interface"></a></h3>
<p>Long options begin with two hyphens (<tt>--</tt>), followed by multiple letters, digits, hyphens, question marks, or dots. A hyphen cannot be the first character of a long option specification when configuring the parser.</p>
<p>Whereas short options can be configured using a constructor argument to <tt>OptionParser</tt>, both long and short options can be configured using a &quot;fluent interface&quot; API, that enables some very descriptive and powerful features.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class LongOptionsTest {
    @Test
    public void acceptsLongOptions() {
        OptionParser parser = new OptionParser();
        parser.accepts( &quot;flag&quot; );
        parser.accepts( &quot;verbose&quot; );

        OptionSet options = parser.parse( &quot;--flag&quot; );

        assertTrue( options.has( &quot;flag&quot; ) );
        assertFalse( options.has( &quot;verbose&quot; ) );
    }
}
</pre></div>
<div class="section">
<h4>Arguments of Options<a name="Arguments_of_Options"></a></h4>
<p>Like short options, long options can accept single arguments. The argument can be made required or optional. Use the methods <tt>withRequiredArg()</tt> and <tt>withOptionalArg()</tt> on the return value of <tt>OptionParser.accepts()</tt> to signal that an option takes a required or optional argument.</p>
<div class="source">
<pre>package joptsimple.examples;

import static java.util.Arrays.*;
import static java.util.Collections.*;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class LongOptionsWithArgumentsTest {
    @Test
    public void supportsLongOptionsWithArgumentsAndAbbreviations() {
        OptionParser parser = new OptionParser();
        parser.accepts( &quot;flag&quot; );
        parser.accepts( &quot;count&quot; ).withRequiredArg();
        parser.accepts( &quot;level&quot; ).withOptionalArg();

        OptionSet options = parser.parse( &quot;-flag&quot;, &quot;--co&quot;, &quot;3&quot;, &quot;--lev&quot; );

        assertTrue( options.has( &quot;flag&quot; ) );

        assertTrue( options.has( &quot;count&quot; ) );
        assertTrue( options.hasArgument( &quot;count&quot; ) );
        assertEquals( &quot;3&quot;, options.valueOf( &quot;count&quot; ) );
        assertEquals( asList( &quot;3&quot; ), options.valuesOf( &quot;count&quot; ) );

        assertTrue( options.has( &quot;level&quot; ) );
        assertFalse( options.hasArgument( &quot;level&quot; ) );
        assertNull( options.valueOf( &quot;level&quot; ) );
        assertEquals( emptyList(), options.valuesOf( &quot;level&quot; ) );
    }
}
</pre></div></div>
<div class="section">
<h4>Abbreviating Long Options<a name="Abbreviating_Long_Options"></a></h4>
<p>Notice in the example above that the command line uses abbreviations of command line options. You can abbreviate options so long as the abbreviation is unambiguous. Even though you can abbreviate the options on the command line, you cannot address the <tt>OptionSet</tt> using those abbreviations.</p></div>
<div class="section">
<h4>Using Single Hyphen on Long Options<a name="Using_Single_Hyphen_on_Long_Options"></a></h4>
<p>As demonstrated in the example above, you can use a single hyphen instead of a double hyphen to specify a long option -- but be careful that doing so doesn't introduce ambiguity.</p>
<div class="section">
<h5>Specifying Arguments for a Long Option on the Command Line<a name="Specifying_Arguments_for_a_Long_Option_on_the_Command_Line"></a></h5>
<p>A long option's argument can occur:</p>
<ul>
<li>in the position on the command line after the option</li>
<li>right up against the option separated by an equals sign (<tt>=</tt>)</li></ul>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class LongOptionsWithArgumentPositioningTest {
    @Test
    public void allowsDifferentFormsOfPairingArgumentWithOption() {
        OptionParser parser = new OptionParser();
        parser.accepts( &quot;count&quot; ).withRequiredArg();
        parser.accepts( &quot;level&quot; ).withOptionalArg();

        OptionSet options = parser.parse( &quot;--count&quot;, &quot;4&quot;, &quot;--level=3&quot; );

        assertTrue( options.has( &quot;count&quot; ) );
        assertTrue( options.hasArgument( &quot;count&quot; ) );
        assertEquals( &quot;4&quot;, options.valueOf( &quot;count&quot; ) );

        assertTrue( options.has( &quot;level&quot; ) );
        assertTrue( options.hasArgument( &quot;level&quot; ) );
        assertEquals( &quot;3&quot;, options.valueOf( &quot;level&quot; ) );
    }
}
</pre></div></div>
<div class="section">
<h5>Multiple Arguments for a Single Option<a name="Multiple_Arguments_for_a_Single_Option"></a></h5>
<p>Specify multiple arguments for a long option in the same manner as for short options (see above).</p></div></div>
<div class="section">
<h4>Alternative Form of Long Options<a name="Alternative_Form_of_Long_Options"></a></h4>
<p>The option <tt>-W</tt> is reserved. If you tell the parser to recognize alternative long options, then it will treat, for example, <tt>-W foo=bar</tt> as the long option <tt>foo</tt> with argument bar, as though you had written <tt>--foo=bar</tt>.</p>
<p>You can specify <tt>-W</tt> as a valid short option, or use it as an abbreviation for a long option, but recognizing alternative long options will always supersede this behavior.</p>
<p>To recognize alternative long options, either construct an <tt>OptionParser</tt> with a string of short option characters containing the sequence <tt>W;</tt> (a capital W followed by a semicolon), or call the method <tt>OptionParser.recognizeAlternativeLongOptions()</tt>.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class AlternativeLongOptionsTest {
    @Test
    public void handlesAlternativeLongOptions() {
        OptionParser parser = new OptionParser( &quot;W;&quot; );
        parser.recognizeAlternativeLongOptions( true );  // same effect as above
        parser.accepts( &quot;level&quot; ).withRequiredArg();

        OptionSet options = parser.parse( &quot;-W&quot;, &quot;level=5&quot; );

        assertTrue( options.has( &quot;level&quot; ) );
        assertTrue( options.hasArgument( &quot;level&quot; ) );
        assertEquals( &quot;5&quot;, options.valueOf( &quot;level&quot; ) );
    }
}
</pre></div></div></div>
<div class="section">
<h3>Other Features<a name="Other_Features"></a></h3>
<div class="section">
<h4>Converting Option Arguments to Other Types<a name="Converting_Option_Arguments_to_Other_Types"></a></h4>
<p>Without action other than the <tt>with*Arg()</tt> methods, arguments of options are returned as <tt>String</tt>s. For backwards compatibility, <tt>OptionSet.valueOf(String)</tt> and <tt>OptionSet.valuesOf(String)</tt> return <tt>Object</tt> and <tt>List&lt;?</tt>&gt;, respectively, so to get the values out as <tt>String</tt>s, you will need to downcast the results of those methods.</p>
<p>You can tell JOpt Simple to convert the arguments of options to different Java types via the <tt>ofType()</tt> method on the return value of <tt>with*Arg()</tt>. The <tt>Class</tt> argument of <tt>ofType()</tt> must represent a Java class that has either:</p>
<ul>
<li>a <tt>public static</tt> method called <tt>valueOf()</tt> which accepts a single <tt>String</tt> argument and whose return type is the type itself, or</li>
<li>a <tt>public</tt> constructor which takes a single <tt>String</tt> argument.</li></ul>
<p>If the class has both, the <tt>valueOf()</tt> method is used.</p>
<p>Note that <tt>enum</tt>s have a <tt>valueOf()</tt> method.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class OptionArgumentValueTypeTest {
    @Test
    public void convertsArgumentsToJavaValueTypes() {
        OptionParser parser = new OptionParser();
        parser.accepts( &quot;flag&quot; );
        parser.accepts( &quot;count&quot; ).withRequiredArg().ofType( Integer.class );
        parser.accepts( &quot;level&quot; ).withOptionalArg().ofType( Level.class );

        OptionSet options = parser.parse( &quot;--count&quot;, &quot;3&quot;, &quot;--level&quot;, &quot;DEBUG&quot; );

        assertTrue( options.has( &quot;count&quot; ) );
        assertTrue( options.hasArgument( &quot;count&quot; ) );
        assertEquals( Integer.valueOf( 3 ), options.valueOf( &quot;count&quot; ) );

        assertTrue( options.has( &quot;level&quot; ) );
        assertTrue( options.hasArgument( &quot;level&quot; ) );
        assertEquals( Level.DEBUG, options.valueOf( &quot;level&quot; ) );
    }
}
</pre></div>
<p>Another way to convert arguments of options is to specify a converter object via <tt>withValuesConvertedBy()</tt>. This is useful when the desired type for the arguments does not meet the requirements that <tt>ofType()</tt> sets forth. Such objects may not perform any &quot;conversion&quot; at all, but rather can validate that arguments conform to certain restrictions before passing through as-is.</p>
<p>You can also do this for the non-option arguments of your command line, if you desire to treat them all as a single type.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.joda.time.DateMidnight;
import org.junit.Test;

import static joptsimple.util.DateConverter.*;
import static joptsimple.util.RegexMatcher.*;
import static org.junit.Assert.*;

public class OptionArgumentConverterTest {
    @Test
    public void usesConvertersOnOptionArgumentsWhenTold() {
        OptionParser parser = new OptionParser();
        parser.accepts( &quot;birthdate&quot; ).withRequiredArg().withValuesConvertedBy( datePattern( &quot;MM/dd/yy&quot; ) );
        parser.accepts( &quot;ssn&quot; ).withRequiredArg().withValuesConvertedBy( regex( &quot;\\d{3}-\\d{2}-\\d{4}&quot; ));

        OptionSet options = parser.parse( &quot;--birthdate&quot;, &quot;02/24/05&quot;, &quot;--ssn&quot;, &quot;123-45-6789&quot; );

        assertEquals( new DateMidnight( 2005, 2, 24 ).toDate(), options.valueOf( &quot;birthdate&quot; ) );
        assertEquals( &quot;123-45-6789&quot;, options.valueOf( &quot;ssn&quot; ) );
    }
}
</pre></div></div>
<div class="section">
<h4>Retrieving Arguments of Options in a Type-Safe Manner<a name="Retrieving_Arguments_of_Options_in_a_Type-Safe_Manner"></a></h4>
<p>In the previous examples, we have been discarding the return values of the methods of JOpt Simple's fluent interface. If instead you retain them in variables of type <tt>OptionSpec</tt>, you can use them to retrieve arguments of options in a type-safe manner.</p>
<p>You can also do this for the non-option arguments of your command line, if you desire to treat them all as a single type.</p>
<div class="source">
<pre>package joptsimple.examples;

import java.io.File;

import static java.util.Arrays.*;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import joptsimple.OptionSpec;
import org.junit.Test;

import static org.junit.Assert.*;

public class TypesafeOptionArgumentRetrievalTest {
    @Test
    public void allowsTypesafeRetrievalOfOptionArguments() {
        OptionParser parser = new OptionParser();
        OptionSpec&lt;Integer&gt; count = parser.accepts( &quot;count&quot; ).withRequiredArg().ofType( Integer.class );
        OptionSpec&lt;File&gt; outputDir = parser.accepts( &quot;output-dir&quot; ).withOptionalArg().ofType( File.class );
        OptionSpec&lt;Void&gt; verbose = parser.accepts( &quot;verbose&quot; );
        OptionSpec&lt;File&gt; files = parser.nonOptions().ofType( File.class );

        OptionSet options = parser.parse( &quot;--count&quot;, &quot;3&quot;, &quot;--output-dir&quot;, &quot;/tmp&quot;, &quot;--verbose&quot;, &quot;a.txt&quot;, &quot;b.txt&quot; );

        assertTrue( options.has( verbose ) );

        assertTrue( options.has( count ) );
        assertTrue( options.hasArgument( count ) );
        Integer expectedCount = 3;
        assertEquals( expectedCount, options.valueOf( count ) );
        assertEquals( expectedCount, count.value( options ) );
        assertEquals( asList( expectedCount ), options.valuesOf( count ) );
        assertEquals( asList( expectedCount ), count.values( options ) );
        assertEquals( asList( new File( &quot;a.txt&quot; ), new File( &quot;b.txt&quot; ) ), options.valuesOf( files ) );

        assertTrue( options.has( outputDir ) );
        assertTrue( options.hasArgument( outputDir ) );
        File expectedFile = new File( &quot;/tmp&quot; );
        assertEquals( expectedFile, options.valueOf( outputDir ) );
        assertEquals( expectedFile, outputDir.value( options ) );
        assertEquals( asList( expectedFile ), options.valuesOf( outputDir ) );
        assertEquals( asList( expectedFile ), outputDir.values( options ) );
        assertEquals( asList( new File( &quot;a.txt&quot; ), new File( &quot;b.txt&quot; ) ), files.values( options ) );
    }
}
</pre></div></div>
<div class="section">
<h4>Exporting Options and Arguments to other Code<a name="Exporting_Options_and_Arguments_to_other_Code"></a></h4>
<p>As an integration aid for other libraries, you can use <tt>OptionSet.asMap()</tt> to obtain a mapping of <tt>OptionSpec</tt> to option values, for example to create a properties map of options.</p>
<p>Here is sample code to create properties whose keys have a common prefix. The key is choosen as the first non-short option:</p>
<div class="source">
<pre>package joptsimple.examples;

import com.google.common.base.Joiner;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import joptsimple.OptionSpec;
import org.junit.Test;

import java.io.File;
import java.util.List;
import java.util.Map.Entry;
import java.util.Properties;

import static org.junit.Assert.assertEquals;

public class ExportOptionsTest {
    private static Properties asProperties( OptionSet options, String prefix ) {
        Properties properties = new Properties();
        for ( Entry&lt;OptionSpec&lt;?&gt;, List&lt;?&gt;&gt; entry : options.asMap().entrySet() ) {
            OptionSpec&lt;?&gt; spec = entry.getKey();
            properties.setProperty(
                asPropertyKey( prefix, spec ),
                asPropertyValue( entry.getValue(), options.has( spec ) ) );
        }
        return properties;
    }

    private static String asPropertyKey( String prefix, OptionSpec&lt;?&gt; spec ) {
        List&lt;String&gt; flags = spec.options();
        for ( String flag : flags )
            if ( 1 &lt; flag.length() )
                return null == prefix ? flag : ( prefix + '.' + flag );
        throw new IllegalArgumentException( &quot;No usable non-short flag: &quot; + flags );
    }

    private static String asPropertyValue( List&lt;?&gt; values, boolean present ) {
        // Simple flags have no values; treat presence/absence as true/false
        return values.isEmpty() ? String.valueOf( present ) : Joiner.on( &quot;,&quot; ).join( values );
    }

    @Test
    public void allowsExportOfOptions() {
        Properties expected = new Properties();
        expected.setProperty( &quot;rice.count&quot;, &quot;3&quot; );
        // Cannot check path as string directly - Windows flips the leading slash
        expected.setProperty( &quot;rice.output-dir&quot;, new File( &quot;/tmp&quot; ).toString() );
        expected.setProperty( &quot;rice.fun&quot;, &quot;false&quot; );
        expected.setProperty( &quot;rice.verbose&quot;, &quot;true&quot; );

        OptionParser parser = new OptionParser();
        OptionSpec&lt;Integer&gt; count = parser.accepts( &quot;count&quot; ).withRequiredArg().ofType( Integer.class );
        OptionSpec&lt;File&gt; outputDir = parser.accepts( &quot;output-dir&quot; ).withOptionalArg().ofType( File.class );
        OptionSpec&lt;Void&gt; verbose = parser.accepts( &quot;verbose&quot; );
        OptionSpec&lt;Void&gt; fun = parser.accepts( &quot;fun&quot; );
        OptionSpec&lt;File&gt; files = parser.nonOptions().ofType( File.class );

        OptionSet options = parser.parse( &quot;--count&quot;, &quot;3&quot;, &quot;--output-dir&quot;, &quot;/tmp&quot;, &quot;--verbose&quot;, &quot;a.txt&quot;, &quot;b.txt&quot; );

        assertEquals( expected, asProperties( options, &quot;rice&quot; ) );
    }
}
</pre></div></div>
<div class="section">
<h4>Default Values for Option Arguments<a name="Default_Values_for_Option_Arguments"></a></h4>
<p>Often it is convenient to specify default values for the arguments of certain command line options. To do this, call the <tt>defaultsTo()</tt> method.</p>
<div class="source">
<pre>package joptsimple.examples;

import java.io.File;

import joptsimple.OptionException;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import joptsimple.OptionSpec;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import static joptsimple.examples.Level.*;
import static org.junit.Assert.*;
import static org.junit.rules.ExpectedException.*;

public class DefaultValuesForOptionArgumentsTest {
    @Rule public final ExpectedException thrown = none();

    @Test
    public void allowsSpecificationOfDefaultValues() throws Exception {
        File tempDir = new File( System.getProperty( &quot;java.io.tmpdir&quot; ) );
        File tempFile = File.createTempFile( &quot;aFile&quot;, &quot;.txt&quot; );
        OptionParser parser = new OptionParser();
        OptionSpec&lt;File&gt; infile =
            parser.accepts( &quot;infile&quot; ).withRequiredArg().ofType( File.class ).defaultsTo( tempFile );
        OptionSpec&lt;File&gt; outdir =
            parser.accepts( &quot;outdir&quot; ).withRequiredArg().ofType( File.class ).defaultsTo( tempDir );
        OptionSpec&lt;Integer&gt; bufferSize =
            parser.accepts( &quot;buffer-size&quot; ).withOptionalArg().ofType( Integer.class ).defaultsTo( 4096 );
        OptionSpec&lt;Level&gt; level =
            parser.accepts( &quot;level&quot; ).withOptionalArg().ofType( Level.class ).defaultsTo( INFO );
        OptionSpec&lt;Integer&gt; count =
            parser.accepts( &quot;count&quot; ).withOptionalArg().ofType( Integer.class ).defaultsTo( 10 );

        OptionSet options = parser.parse( &quot;--level&quot;, &quot;WARNING&quot;, &quot;--count&quot;, &quot;--infile&quot;, &quot;/etc/passwd&quot; );

        assertEquals( new File( &quot;/etc/passwd&quot; ), infile.value( options ) );
        assertTrue( options.has( infile ) );
        assertTrue( options.hasArgument( infile ) );
        assertEquals( tempDir, outdir.value( options ) );
        assertFalse( options.has( outdir ) );
        assertFalse( options.hasArgument( outdir ) );
        assertEquals( Integer.valueOf( 4096 ), bufferSize.value( options ) );
        assertFalse( options.has( bufferSize ) );
        assertFalse( options.hasArgument( bufferSize ) );
        assertEquals( WARNING, level.value( options ) );
        assertTrue( options.has( level ) );
        assertTrue( options.hasArgument( level ) );
        assertEquals( Integer.valueOf( 10 ), count.value( options ) );
        assertTrue( options.has( count ) );
        assertFalse( options.hasArgument( count ) );

        thrown.expect( OptionException.class );

        parser.parse( &quot;--outdir&quot; );
    }
}
</pre></div>
<p>You can see that <tt>defaultsTo()</tt> should relieve you of the burden of having to check <tt>has()</tt> and/or <tt>hasArgument()</tt> on an <tt>OptionSet</tt> for a given option, and has no bearing on the return values of those methods. Specifying a default value for an option with a required argument does not mean that you can elide an argument for the option on the command line.</p>
<p>The type of values <tt>defaultsTo()</tt> expects is dictated by the class given by a previous call to <tt>ofType()</tt> or <tt>withValuesConvertedBy()</tt>; if no such call has been made, the type is <tt>String</tt>.</p></div>
<div class="section">
<h4>&quot;Required&quot; Options<a name="aRequired_Options"></a></h4>
<p>You can indicate that a given option must be present on the command line via the <tt>required()</tt> method. Only options that accept arguments can be made &quot;required&quot;.</p>
<p>An option designated as a &quot;help&quot; option via <tt>forHelp()</tt>, when present on the command line, causes missing &quot;required&quot; options not to reject the command line.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionException;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class RequiredOptionsTest {
    @Test( expected = OptionException.class )
    public void allowsSpecificationOfRequiredOptions() {
        OptionParser parser = new OptionParser() {
            {
                accepts( &quot;userid&quot; ).withRequiredArg().required();
                accepts( &quot;password&quot; ).withRequiredArg().required();
            }
        };

        parser.parse( &quot;--userid&quot;, &quot;bob&quot; );
    }

    @Test
    public void aHelpOptionMeansRequiredOptionsNeedNotBePresent() {
        OptionParser parser = new OptionParser() {
            {
                accepts( &quot;userid&quot; ).withRequiredArg().required();
                accepts( &quot;password&quot; ).withRequiredArg().required();
                accepts( &quot;help&quot; ).forHelp();
            }
        };

        OptionSet options = parser.parse( &quot;--help&quot; );
        assertTrue( options.has( &quot;help&quot; ) );
    }
    
    @Test( expected = OptionException.class )
    public void missingHelpOptionMeansRequiredOptionsMustBePresent() {
        OptionParser parser = new OptionParser() {
            {
                accepts( &quot;userid&quot; ).withRequiredArg().required();
                accepts( &quot;password&quot; ).withRequiredArg().required();
                accepts( &quot;help&quot; ).forHelp();
            }
        };

        parser.parse( &quot;&quot; );
    }
}
</pre></div></div>
<div class="section">
<h4>&quot;Required&quot; Dependent Options<a name="aRequired_Dependent_Options"></a></h4>
<p>You can indicate that a given option must be present on the command line if some other option is present on the command line via the <tt>requiredIf()</tt> method. Any option can be made &quot;required if&quot;.</p>
<p>An option designated as a &quot;help&quot; option via <tt>forHelp()</tt>, when present on the command line, causes missing &quot;required if&quot; options not to reject the command line.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;

public class RequiredIfExample {
    public static void main( String[] args ) {
        OptionParser parser = new OptionParser();
        parser.accepts( &quot;ftp&quot; );
        parser.accepts( &quot;username&quot; ).requiredIf( &quot;ftp&quot; ).withRequiredArg();
        parser.accepts( &quot;password&quot; ).requiredIf( &quot;ftp&quot; ).withRequiredArg();

        parser.parse( &quot;--ftp&quot; );
    }
}
</pre></div>
<p>You can also indicate that a given option must be present on the command line if some other option is NOT present on the command line via the <tt>requiredUnless()</tt> method. Any option can be made &quot;required unless&quot;, but, to avoid potential conflicts, it should not be &quot;required if&quot; at the same time.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;

public class RequiredUnlessExample {
    public static void main( String[] args ) {
        OptionParser parser = new OptionParser();
        parser.accepts( &quot;anonymous&quot; );
        parser.accepts( &quot;username&quot; ).requiredUnless( &quot;anonymous&quot; ).withRequiredArg();
        parser.accepts( &quot;password&quot; ).requiredUnless( &quot;anonymous&quot; ).withRequiredArg();

        parser.parse( &quot;--anonymous&quot; );
    }
}
</pre></div></div>
<div class="section">
<h4>Synonyms of Options<a name="Synonyms_of_Options"></a></h4>
<p>Sometimes it is useful to allow many different options to share the same meaning in the program that uses them. To specify that options are to be treated as synonymous, use the <tt>acceptsAll()</tt> method of <tt>OptionParser</tt>.</p>
<div class="source">
<pre>package joptsimple.examples;

import java.util.List;

import static java.util.Arrays.*;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class OptionSynonymTest {
    @Test
    public void supportsOptionSynonyms() {
        OptionParser parser = new OptionParser();
        List&lt;String&gt; synonyms = asList( &quot;message&quot;, &quot;blurb&quot;, &quot;greeting&quot; );
        parser.acceptsAll( synonyms ).withRequiredArg();
        String expectedMessage = &quot;Hello&quot;;

        OptionSet options = parser.parse( &quot;--message&quot;, expectedMessage );

        for ( String each : synonyms ) {
            assertTrue( each, options.has( each ) );
            assertTrue( each, options.hasArgument( each ) );
            assertEquals( each, expectedMessage, options.valueOf( each ) );
            assertEquals( each, asList( expectedMessage ), options.valuesOf( each ) );
        }
    }
}
</pre></div></div>
<div class="section">
<h4>Concise Specification of Multiple Arguments for an Option<a name="Concise_Specification_of_Multiple_Arguments_for_an_Option"></a></h4>
<p>Another way to specify multiple arguments for an option is to tell the parser to treat a single argument containing multiple delimited values as multiple arguments for the option using the <tt>withValuesSeparatedBy()</tt> method.</p>
<div class="source">
<pre>package joptsimple.examples;

import java.io.File;

import static java.io.File.*;
import static java.util.Arrays.*;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import joptsimple.OptionSpec;
import org.junit.Test;

import static joptsimple.examples.Strings.*;
import static org.junit.Assert.*;

public class MultipleDelimitedArgumentsTest {
    @Test
    public void supportsMultipleDelimitedArguments() {
        OptionParser parser = new OptionParser();
        OptionSpec&lt;File&gt; path = parser.accepts( &quot;path&quot; ).withRequiredArg().ofType( File.class )
            .withValuesSeparatedBy( pathSeparatorChar );

        OptionSet options = parser.parse( &quot;--path&quot;, join( pathSeparatorChar, &quot;/tmp&quot;, &quot;/var&quot;, &quot;/opt&quot; ) );

        assertTrue( options.has( path ) );
        assertTrue( options.hasArgument( path ) );
        assertEquals( asList( new File( &quot;/tmp&quot; ), new File( &quot;/var&quot; ), new File( &quot;/opt&quot; ) ), options.valuesOf( path ) );
    }
}
</pre></div></div>
<div class="section">
<h4>Signalling End of Options<a name="Signalling_End_of_Options"></a></h4>
<p>An argument consisting only of two hyphens (<tt>--</tt>) signals that the remaining arguments are to be treated as non-options.</p>
<p>An argument consisting only of a single hyphen is considered a non-option argument (though it can be an argument of an option). Many Unix programs treat single hyphens as stand-ins for the standard input or standard output stream.</p>
<div class="section">
<h5>Non-Option Arguments<a name="Non-Option_Arguments"></a></h5>
<p>Any arguments which are not options or arguments of options can be retrieved via method <tt>nonOptionArguments()</tt> on <tt>OptionSet</tt>. If the double hyphen is an argument, it is ignored and is not a non-option argument.</p>
<div class="source">
<pre>package joptsimple.examples;

import static java.util.Arrays.*;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class SignallingEndOfOptionsTest {
    @Test
    public void doubleHyphenSignalsEndOfOptions() {
        OptionParser parser = new OptionParser( &quot;ab:c::de:f::&quot; );

        OptionSet options = parser.parse( &quot;-a&quot;, &quot;-b=foo&quot;, &quot;-c=bar&quot;, &quot;--&quot;, &quot;-d&quot;, &quot;-e&quot;, &quot;baz&quot;, &quot;-f&quot;, &quot;biz&quot; );

        assertTrue( options.has( &quot;a&quot; ) );
        assertFalse( options.hasArgument( &quot;a&quot; ) );
        assertTrue( options.has( &quot;b&quot; ) );
        assertTrue( options.hasArgument( &quot;b&quot; ) );
        assertEquals( asList( &quot;foo&quot; ), options.valuesOf( &quot;b&quot; ) );
        assertTrue( options.has( &quot;c&quot; ) );
        assertTrue( options.hasArgument( &quot;c&quot; ) );
        assertEquals( asList( &quot;bar&quot; ), options.valuesOf( &quot;c&quot; ) );
        assertFalse( options.has( &quot;d&quot; ) );
        assertFalse( options.has( &quot;e&quot; ) );
        assertFalse( options.has( &quot;f&quot; ) );
        assertEquals( asList( &quot;-d&quot;, &quot;-e&quot;, &quot;baz&quot;, &quot;-f&quot;, &quot;biz&quot; ), options.nonOptionArguments() );
    }
}
</pre></div></div></div>
<div class="section">
<h4>&quot;POSIX-ly Correct&quot;-ness<a name="aPOSIX-ly_Correct-ness"></a></h4>
<p>By default, as with GNU <tt>getopt()</tt>, JOpt Simple allows intermixing of options and non-options. If, however, the parser has been created to be &quot;POSIX-ly correct&quot;, then the first argument that does not look lexically like an option, and is not a required argument of a preceding option, signals the end of options. You can still bind optional arguments to their options using the abutting (for short options) or <tt>=</tt> syntax.</p>
<p>Unlike GNU <tt>getopt()</tt>, JOptSimple does not honor the environment variable <tt>POSIXLY_CORRECT</tt>. &quot;POSIX-ly correct&quot; parsers are configured by either:</p>
<ul>
<li>using the method <tt>OptionParser.posixlyCorrect()</tt></li>
<li>using the <tt>OptionParser</tt> constructor with an argument whose first character is a plus sign (<tt>+</tt>)</li></ul>
<div class="source">
<pre>package joptsimple.examples;

import static java.util.Arrays.*;
import static java.util.Collections.*;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class PosixlyCorrectTest {
    @Test
    public void supportsPosixlyCorrectBehavior() {
        OptionParser parser = new OptionParser( &quot;i:j::k&quot; );
        String[] arguments = { &quot;-ibar&quot;, &quot;-i&quot;, &quot;junk&quot;, &quot;xyz&quot;, &quot;-jixnay&quot;, &quot;foo&quot;, &quot;-k&quot;, &quot;blah&quot;, &quot;--&quot;, &quot;bah&quot; };

        OptionSet options = parser.parse( arguments );

        assertTrue( options.has( &quot;i&quot; ) );
        assertTrue( options.has( &quot;j&quot; ) );
        assertTrue( options.has( &quot;k&quot; ) );
        assertEquals( asList( &quot;bar&quot;, &quot;junk&quot; ), options.valuesOf( &quot;i&quot; ) );
        assertEquals( asList( &quot;ixnay&quot; ), options.valuesOf( &quot;j&quot; ) );
        assertEquals( asList( &quot;xyz&quot;, &quot;foo&quot;, &quot;blah&quot;, &quot;bah&quot; ), options.nonOptionArguments() );

        parser.posixlyCorrect( true );
        options = parser.parse( arguments );

        assertTrue( options.has( &quot;i&quot; ) );
        assertFalse( options.has( &quot;j&quot; ) );
        assertFalse( options.has( &quot;k&quot; ) );
        assertEquals( asList( &quot;bar&quot;, &quot;junk&quot; ), options.valuesOf( &quot;i&quot; ) );
        assertEquals( emptyList(), options.valuesOf( &quot;j&quot; ) );
        assertEquals( asList( &quot;xyz&quot;, &quot;-jixnay&quot;, &quot;foo&quot;, &quot;-k&quot;, &quot;blah&quot;, &quot;--&quot;, &quot;bah&quot; ), options.nonOptionArguments() );
    }
}
</pre></div></div>
<div class="section">
<h4>Special Optional Argument Handling<a name="Special_Optional_Argument_Handling"></a></h4>
<p>If the parser detects an option whose argument is optional, and the next argument &quot;looks like&quot; an option, that argument is not treated as the argument to the option, but as a potentially valid option. If, on the other hand, the optional argument is typed as a derivative of <tt>Number</tt>, then that argument is treated as the negative number argument of the option, even if the parser recognizes the corresponding numeric option.</p>
<div class="source">
<pre>package joptsimple.examples;

import static java.util.Arrays.*;
import static java.util.Collections.*;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static org.junit.Assert.*;

public class SpecialOptionalArgumentHandlingTest {
    @Test
    public void handlesNegativeNumberOptionalArguments() {
        OptionParser parser = new OptionParser();
        parser.accepts( &quot;a&quot; ).withOptionalArg().ofType( Integer.class );
        parser.accepts( &quot;2&quot; );

        OptionSet options = parser.parse( &quot;-a&quot;, &quot;-2&quot; );

        assertTrue( options.has( &quot;a&quot; ) );
        assertFalse( options.has( &quot;2&quot; ) );
        assertEquals( asList( -2 ), options.valuesOf( &quot;a&quot; ) );

        options = parser.parse( &quot;-2&quot;, &quot;-a&quot; );

        assertTrue( options.has( &quot;a&quot; ) );
        assertTrue( options.has( &quot;2&quot; ) );
        assertEquals( emptyList(), options.valuesOf( &quot;a&quot; ) );
    }
}
</pre></div></div></div></div>
<div class="section">
<h2>Generating Command Line Help<a name="Generating_Command_Line_Help"></a></h2>
<p>When you call method <tt>OptionParser.printHelpOn()</tt>, JOpt Simple will write a help screen (80-column width) describing all the options it is configured with, along with types of option arguments, whether the option is required (in angle brackets) or optional (in square brackets), etc. To give an option a description, use <tt>OptionParser.accepts*()</tt> with a description argument. To give an option argument a description, use <tt>describedAs()</tt> on the return value of <tt>with*Arg()</tt>.</p>
<div class="source">
<pre>package joptsimple.examples;

import java.io.File;

import static java.io.File.*;
import static java.util.Arrays.*;

import joptsimple.OptionParser;

import static joptsimple.util.DateConverter.*;

public class HelpScreenExample {
    public static void main( String[] args ) throws Exception {
        OptionParser parser = new OptionParser() {
            {
                accepts( &quot;c&quot; ).withRequiredArg().ofType( Integer.class )
                    .describedAs( &quot;count&quot; ).defaultsTo( 1 );
                accepts( &quot;q&quot; ).withOptionalArg().ofType( Double.class )
                    .describedAs( &quot;quantity&quot; );
                accepts( &quot;d&quot;, &quot;some date&quot; ).withRequiredArg().required()
                    .withValuesConvertedBy( datePattern( &quot;MM/dd/yy&quot; ) );
                acceptsAll( asList( &quot;v&quot;, &quot;talkative&quot;, &quot;chatty&quot; ), &quot;be more verbose&quot; );
                accepts( &quot;output-file&quot; ).withOptionalArg().ofType( File.class )
                     .describedAs( &quot;file&quot; );
                acceptsAll( asList( &quot;h&quot;, &quot;?&quot; ), &quot;show help&quot; ).forHelp();
                acceptsAll( asList( &quot;cp&quot;, &quot;classpath&quot; ) ).withRequiredArg()
                    .describedAs( &quot;path1&quot; + pathSeparatorChar + &quot;path2:...&quot; )
                    .ofType( File.class )
                    .withValuesSeparatedBy( pathSeparatorChar );
            }
        };

        parser.printHelpOn( System.out );
    }
}
</pre></div>
<p>Here is what the help screen looks like for the example above:</p>
<div class="source">
<pre>Option (* = required)            Description    
---------------------            -----------    
-?, -h                           show help      
-c &lt;Integer: count&gt;              (default: 1)   
--classpath, --cp &lt;File: path1:                 
  path2:...&gt;                                    
* -d &lt;MM/dd/yy&gt;                  some date      
--output-file [File: file]                      
-q [Double: quantity]                           
-v, --chatty, --talkative        be more verbose
</pre></div>
<p>If you want to create your own help screen, give method <tt>OptionParser.formatHelpWith()</tt> a <tt>HelpFormatter</tt> that builds the help screen as a String. When you call <tt>OptionParser.printHelpOn()</tt>, JOpt Simple will use your <tt>HelpFormatter</tt> to produce the help and write it to the given stream.</p>
<p>For example, this program:</p>
<div class="source">
<pre>package joptsimple.examples;

import java.io.File;
import java.util.HashSet;
import java.util.Map;

import static java.io.File.*;
import static java.util.Arrays.*;

import joptsimple.HelpFormatter;
import joptsimple.OptionDescriptor;
import joptsimple.OptionParser;

import static joptsimple.util.DateConverter.*;

public class HelpFormatterExample {
    static class MyFormatter implements HelpFormatter {
        public String format( Map&lt;String, ? extends OptionDescriptor&gt; options ) {
            StringBuilder buffer = new StringBuilder();
            for ( OptionDescriptor each : new HashSet&lt;OptionDescriptor&gt;( options.values() ) ) {
                buffer.append( lineFor( each ) );
            }
            return buffer.toString();
        }

        private String lineFor( OptionDescriptor descriptor ) {
            if ( descriptor.representsNonOptions() ) {
                return descriptor.argumentDescription() + '(' + descriptor.argumentTypeIndicator() + &quot;): &quot;
                    + descriptor.description() + System.getProperty( &quot;line.separator&quot; );
            }

            StringBuilder line = new StringBuilder( descriptor.options().toString() );
            line.append( &quot;: description = &quot; ).append( descriptor.description() );
            line.append( &quot;, required = &quot; ).append( descriptor.isRequired() );
            line.append( &quot;, accepts arguments = &quot; ).append( descriptor.acceptsArguments() );
            line.append( &quot;, requires argument = &quot; ).append( descriptor.requiresArgument() );
            line.append( &quot;, argument description = &quot; ).append( descriptor.argumentDescription() );
            line.append( &quot;, argument type indicator = &quot; ).append( descriptor.argumentTypeIndicator() );
            line.append( &quot;, default values = &quot; ).append( descriptor.defaultValues() );
            line.append( System.getProperty( &quot;line.separator&quot; ) );
            return line.toString();
        }
    }

    public static void main( String[] args ) throws Exception {
        OptionParser parser = new OptionParser() {
            {
                accepts( &quot;c&quot; ).withRequiredArg().ofType( Integer.class )
                    .describedAs( &quot;count&quot; ).defaultsTo( 1 );
                accepts( &quot;q&quot; ).withOptionalArg().ofType( Double.class )
                    .describedAs( &quot;quantity&quot; );
                accepts( &quot;d&quot;, &quot;some date&quot; ).withRequiredArg().required()
                    .withValuesConvertedBy( datePattern( &quot;MM/dd/yy&quot; ) );
                acceptsAll( asList( &quot;v&quot;, &quot;talkative&quot;, &quot;chatty&quot; ), &quot;be more verbose&quot; );
                accepts( &quot;output-file&quot; ).withOptionalArg().ofType( File.class )
                     .describedAs( &quot;file&quot; );
                acceptsAll( asList( &quot;h&quot;, &quot;?&quot; ), &quot;show help&quot; ).forHelp();
                acceptsAll( asList( &quot;cp&quot;, &quot;classpath&quot; ) ).withRequiredArg()
                    .describedAs( &quot;path1&quot; + pathSeparatorChar + &quot;path2:...&quot; )
                    .ofType( File.class )
                    .withValuesSeparatedBy( pathSeparatorChar );
                nonOptions( &quot;files to chew on&quot; ).ofType( File.class ).describedAs( &quot;input files&quot; );
            }
        };

        parser.formatHelpWith( new MyFormatter() );
        parser.printHelpOn( System.out );
    }
}
</pre></div>
<p>yields the following output:</p>
<div class="source">
<pre>input files(java.io.File): files to chew on
[?, h]: description = show help, required = false, accepts arguments = false, requires argument = false, argument description = , argument type indicator = , default values = []
[d]: description = some date, required = true, accepts arguments = true, requires argument = true, argument description = , argument type indicator = MM/dd/yy, default values = []
[c]: description = , required = false, accepts arguments = true, requires argument = true, argument description = count, argument type indicator = java.lang.Integer, default values = [1]
[classpath, cp]: description = , required = false, accepts arguments = true, requires argument = true, argument description = path1:path2:..., argument type indicator = java.io.File, default values = []
[output-file]: description = , required = false, accepts arguments = true, requires argument = false, argument description = file, argument type indicator = java.io.File, default values = []
[q]: description = , required = false, accepts arguments = true, requires argument = false, argument description = quantity, argument type indicator = java.lang.Double, default values = []
[v, chatty, talkative]: description = be more verbose, required = false, accepts arguments = false, requires argument = false, argument description = , argument type indicator = , default values = []
</pre></div></div>
<div class="section">
<h2>Handling Exceptions<a name="Handling_Exceptions"></a></h2>
<p>JOpt Simple's classes raise some derivative of <tt>OptionException</tt> if they encounter problems during parsing. These exceptions are unchecked, so you don't have to do anything with such an exception if you don't want to. The rationale behind this decision is that you will most likely be invoking JOpt Simple's functionality from a <tt>main()</tt> method or very near to it, where a failure such as unrecognized arguments can just stop down the JVM and yield a stack trace without much user or programmer inconvenience. So, without any exception handling at all, a user would see something like this:</p>
<div class="source">
<pre>Exception in thread &quot;main&quot; joptsimple.UnrecognizedOptionException: x is not a recognized option
	at joptsimple.OptionException.unrecognizedOption(OptionException.java:106)
	at joptsimple.OptionParser.validateOptionCharacters(OptionParser.java:551)
	at joptsimple.OptionParser.handleShortOptionCluster(OptionParser.java:462)
	at joptsimple.OptionParser.handleShortOptionToken(OptionParser.java:457)
	at joptsimple.OptionParserState$2.handleArgument(OptionParserState.java:59)
	at joptsimple.OptionParser.parse(OptionParser.java:376)
	at joptsimple.examples.ExceptionExample.main(ExceptionExample.java:9)
</pre></div>
<p>If you want to handle the exception yourself, you can catch <tt>OptionException</tt> in your code, and do whatever you please with the contents of the exception, perhaps using the help generation facility.</p>
<div class="section">
<h3>Suppressing <tt>UnrecognizedOptionException</tt><a name="Suppressing_UnrecognizedOptionException"></a></h3>
<p>Sometimes you want to ignore unrecognized options on the command line.</p>
<p>For example, you might be interested in handling only a part of the arguments given. Or you might want to pass on options to another program and not bother the user with providing two hyphens (<tt>--</tt>) to indicate the end of known options. Or maybe you want to provide future forwards/backwards compatibility when you foresee passing in new options to old code (or old code invoking new code with &quot;old&quot; arguments).</p>
<p>You can achieve this by using the method <tt>OptionParser.allowsUnrecognizedOptions()</tt>. When you call this method, then any unrecognized options handed to <tt>parse()</tt> are treated as non-option arguments, rather than causing an exception to be raised.</p>
<div class="source">
<pre>package joptsimple.examples;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.junit.Test;

import static java.util.Arrays.*;
import static org.junit.Assert.*;

public class UnrecognizedOptionsAllowedTest {
    @Test
    public void acceptsLongOptions() {
        OptionParser parser = new OptionParser();
        parser.allowsUnrecognizedOptions();
        parser.accepts( &quot;f&quot; );

        OptionSet options = parser.parse( &quot;-f&quot;, &quot;-d&quot; );

        assertTrue( options.has( &quot;f&quot; ) );
        assertFalse( options.has( &quot;d&quot; ) );
        assertEquals( asList( &quot;-d&quot; ), options.nonOptionArguments() );
    }
}
</pre></div></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                   2014.
          All Rights Reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
